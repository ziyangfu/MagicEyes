### Linux 内存可观测性工具—mem_watcher

#### 0. 简介

Linux内存一站式观测与诊断工具。

- 面向内核内存管理子系统的观测（+内核参数调整）（系统健康监控）
- 面向应用程序的内存问题诊断与优化

针对内核：

- 多个内存参数得用多个工具来看？
- proc信息繁杂且无法定制？
- 内核不透明，无法了解内部的具体运行情况？
- 缺乏故障诊断的工具？

针对应用程序：

- valgrind（虚拟机，拖慢进程几十倍，无需重新编译应用程序， 适合程序开发调试）
- ASAN（拖慢进程约2倍，需重新编译应用程序，-fsanitize=address， 适合程序开发调试， 谷歌开发开源，GCC自带）

是否有一款工具，能够基本不影响性能，全天候持续性能观测与诊断？

采用unix哲学， "一个工具只解决一个问题"。通过聚合多个子功能，提供一站式、保姆型、可定制观测与诊断服务。

相关“竞品”工具： stream， lmbench， perf， ftrace， KASAN，UBSAN（内存安全），kfence（内存安全）

持续开发中......

#### 1. 系统性能参数显示

- [ ] 基础参数：
  - [ ] 系统内存容量、交换空间容量、系统内存使用率（free, proc/meminfo）、内存运行带宽
  - [ ] 模仿 `inix -F`的输出格式
  - [ ] 替代 stream 运行带宽测试工具（暂时不需要）
- [ ] 内存读取延迟，内存分配延迟，内存释放延迟
  - [ ] 替代lmbench内存延迟测试工具
  - [ ] 测试不同内存大小与跨度下的内存读取延迟
- [ ] 缺页异常处理耗时

#### 2. 可观测性与故障诊断

- [ ] 分析指定进程或者服务的内存使用情况

  - [ ] paf
  - [ ] pr
  - [ ] procstat
  - [ ] sysstat
- [ ] 进程内存问题跟踪

  - [ ] 内存越界
  - [ ] 内存泄露 memleak
    - [ ] 关于内存泄露：若应用程序或者中间件采用内存池技术，一次划入大量内存，直到退出时才释放内存，如何处理该场景的内存泄露？
  - [ ] 双重释放
    - [ ] 是否可以跟踪kfree，2次调用kfree则是双重释放
    - [ ] 双重释放会让程序运行出错，对于重要的程序，是否可以不响应第二次双重释放，并给出严重报警，使得程序在关键时候不因为双重释放而崩溃，进而在非紧急状态进行修复
  - [ ] 堆栈溢出
    - [ ] 如何做？
    - [ ] 调用栈跟踪， stack analysis
  - [ ] 野指针
    - [ ] 如何做？或者说，这种问题，不用内核来做，交给应用层的检测程序处理
- [ ] 内存分配路径跟踪， mem_trace

  - [ ] Linux内核内存管理的链路追踪
  - [ ] 必要性？市场是否有同类工具
  - [ ] 模仿nettrace工具，预先在分配路径上下钩子
- [ ] 追踪oomkiller
- [ ] 追踪memleak
- [ ] 内存规整，内存碎片追踪：徐东内核模块，主动式监控
- [ ] 缺页异常
- [ ] 巨页 huge page
- [ ] 内存水位线跟踪， low以下

  - [ ] 是否存在从内存使用率上看不出内存的紧急情况，需要跟踪水位线，在一定时刻内，系统处于水位线low以下或者紧急以下的百分比。
- [ ] 系统swap跟踪？
- [ ] 内存分配慢速路径跟踪

#### 3. 全系统诊断—内存部分

#### 4. 有用的资料

[eBPF内存泄露检测代码实现v2](https://blog.csdn.net/qq_38232169/article/details/135579619)
